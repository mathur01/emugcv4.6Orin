//----------------------------------------------------------------------------
//
//  Copyright (C) 2004-2022 by EMGU Corporation. All rights reserved.
//
//  Vector of OclPlatformInfo
//
//  This file is automatically generated, do not modify.
//----------------------------------------------------------------------------



#include "vector_OclPlatformInfo.h"

#if 1



std::vector< cv::ocl::PlatformInfo >* VectorOfOclPlatformInfoCreate() 
{
   return new std::vector< cv::ocl::PlatformInfo >(); 
}

std::vector< cv::ocl::PlatformInfo >* VectorOfOclPlatformInfoCreateSize(int size) 
{
   return new std::vector< cv::ocl::PlatformInfo >(size); 
}

int VectorOfOclPlatformInfoGetSize(std::vector< cv::ocl::PlatformInfo >* v)
{
   return v->size();
}


void VectorOfOclPlatformInfoPush(std::vector< cv::ocl::PlatformInfo >* v, cv::ocl::PlatformInfo* value)
{
   v->push_back(*value);
}

//void VectorOfOclPlatformInfoPushMulti(std::vector< cv::ocl::PlatformInfo >* v,  cv::ocl::PlatformInfo* values, int count)
//{
//   VectorPushMulti< cv::ocl::PlatformInfo >(v, values, count);
//}

void VectorOfOclPlatformInfoPushVector(std::vector< cv::ocl::PlatformInfo >* v, std::vector< cv::ocl::PlatformInfo >* other)
{
   v->insert(v->end(), other->begin(), other->end());
}

void VectorOfOclPlatformInfoClear(std::vector< cv::ocl::PlatformInfo >* v)
{
   v->clear();
}

void VectorOfOclPlatformInfoRelease(std::vector< cv::ocl::PlatformInfo >** v)
{
   delete *v;
   *v = 0;
}

void VectorOfOclPlatformInfoCopyData(std::vector< cv::ocl::PlatformInfo >* v, cv::ocl::PlatformInfo* data)
{
   VectorCopyData< cv::ocl::PlatformInfo >(v, data);
}

cv::ocl::PlatformInfo* VectorOfOclPlatformInfoGetStartAddress(std::vector< cv::ocl::PlatformInfo >* v)
{
   return v->empty() ? NULL : &(*v)[0];
}

int64_t VectorOfOclPlatformInfoGetMemorySize(std::vector< cv::ocl::PlatformInfo >* v)
{
   if (v->empty()) return 0;
   return (int64_t) (v->size() * sizeof(cv::ocl::PlatformInfo));
}

void VectorOfOclPlatformInfoGetItemPtr(std::vector<  cv::ocl::PlatformInfo >* vec, int index,  cv::ocl::PlatformInfo** element)
{
   *element = &vec->at(index);
}

#if true
cv::_InputArray* cveInputArrayFromVectorOfOclPlatformInfo(std::vector< cv::ocl::PlatformInfo >* vec)
{
   return new cv::_InputArray(*vec);
}

cv::_OutputArray* cveOutputArrayFromVectorOfOclPlatformInfo(std::vector< cv::ocl::PlatformInfo >* vec)
{
   return new cv::_OutputArray(*vec);
}

cv::_InputOutputArray* cveInputOutputArrayFromVectorOfOclPlatformInfo(std::vector< cv::ocl::PlatformInfo >* vec)
{
   return new cv::_InputOutputArray(*vec);
}
#endif

int VectorOfOclPlatformInfoSizeOfItemInBytes()
{
   return sizeof(cv::ocl::PlatformInfo);
}

#else

void * VectorOfOclPlatformInfoCreate()
{
   throw_no_vector();
}

void * VectorOfOclPlatformInfoCreateSize(int size)
{
   throw_no_vector();
}

int VectorOfOclPlatformInfoGetSize(void* v)
{
   throw_no_vector();
}

void VectorOfOclPlatformInfoPush(void* v, void* value)
{
   throw_no_vector();
}

//CVAPI(void) VectorOfOclPlatformInfoPushMulti(std::vector< cv::ocl::PlatformInfo >* v, cv::ocl::PlatformInfo* values, int count);

void VectorOfOclPlatformInfoPushVector(void* v, void* other)
{
   throw_no_vector();
}

void VectorOfOclPlatformInfoClear(void* v)
{
   throw_no_vector();
}

void VectorOfOclPlatformInfoRelease(void** v)
{
   throw_no_vector();
}

void VectorOfOclPlatformInfoCopyData(void* v, void* data)
{
   throw_no_vector();
}

void* VectorOfOclPlatformInfoGetStartAddress(void* v)
{
   throw_no_vector();
}

void VectorOfOclPlatformInfoGetItemPtr(void* vec, int index,  void** element)
{
   throw_no_vector();
}

#if true
cv::_InputArray* cveInputArrayFromVectorOfOclPlatformInfo(void* vec)
{
   throw_no_vector();
}

cv::_OutputArray* cveOutputArrayFromVectorOfOclPlatformInfo(void* vec)
{
   throw_no_vector();
}

cv::_InputOutputArray* cveInputOutputArrayFromVectorOfOclPlatformInfo(void* vec)
{
   throw_no_vector();
}
#endif

int VectorOfOclPlatformInfoSizeOfItemInBytes()
{
   throw_no_vector();
}


#endif
